"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CollectionsService = void 0;
const logging_1 = __importDefault(require("@tryghost/logging"));
const tpl_1 = __importDefault(require("@tryghost/tpl"));
const Collection_1 = require("./Collection");
const CollectionResourceChangeEvent_1 = require("./CollectionResourceChangeEvent");
const errors_1 = require("@tryghost/errors");
const PostDeletedEvent_1 = require("./events/PostDeletedEvent");
const PostAddedEvent_1 = require("./events/PostAddedEvent");
const PostEditedEvent_1 = require("./events/PostEditedEvent");
const RepositoryUniqueChecker_1 = require("./RepositoryUniqueChecker");
const messages = {
    cannotDeleteBuiltInCollectionError: {
        message: 'Cannot delete builtin collection',
        context: 'The collection {id} is a builtin collection and cannot be deleted'
    },
    collectionNotFound: {
        message: 'Collection not found',
        context: 'Collection with id: {id} does not exist'
    }
};
class CollectionsService {
    collectionsRepository;
    postsRepository;
    DomainEvents;
    uniqueChecker;
    slugService;
    constructor(deps) {
        this.collectionsRepository = deps.collectionsRepository;
        this.postsRepository = deps.postsRepository;
        this.DomainEvents = deps.DomainEvents;
        this.uniqueChecker = new RepositoryUniqueChecker_1.RepositoryUniqueChecker(this.collectionsRepository);
        this.slugService = deps.slugService;
    }
    toDTO(collection) {
        return {
            id: collection.id,
            title: collection.title,
            slug: collection.slug,
            description: collection.description || null,
            feature_image: collection.featureImage || null,
            type: collection.type,
            filter: collection.filter,
            created_at: collection.createdAt,
            updated_at: collection.updatedAt,
            posts: collection.posts.map((postId, index) => ({
                id: postId,
                sort_order: index
            }))
        };
    }
    fromDTO(data) {
        const mappedDTO = {
            title: data.title,
            slug: data.slug,
            description: data.description,
            featureImage: data.feature_image,
            filter: data.filter
        };
        // delete out keys that contain undefined values
        for (const key of Object.keys(mappedDTO)) {
            if (mappedDTO[key] === undefined) {
                delete mappedDTO[key];
            }
        }
        return mappedDTO;
    }
    /**
     * @description Subscribes to Domain events to update collections when posts are added, updated or deleted
     */
    subscribeToEvents() {
        // generic handler for all events that are not handled optimally yet
        // this handler should go away once we have logic fo reach event
        this.DomainEvents.subscribe(CollectionResourceChangeEvent_1.CollectionResourceChangeEvent, async () => {
            await this.updateCollections();
        });
        this.DomainEvents.subscribe(PostDeletedEvent_1.PostDeletedEvent, async (event) => {
            await this.removePostFromAllCollections(event.id);
        });
        this.DomainEvents.subscribe(PostAddedEvent_1.PostAddedEvent, async (event) => {
            await this.addPostToMatchingCollections(event.data);
        });
        this.DomainEvents.subscribe(PostEditedEvent_1.PostEditedEvent, async (event) => {
            await this.updatePostInMatchingCollections(event.data);
        });
    }
    async createCollection(data) {
        const slug = await this.slugService.generate(data.slug || data.title);
        const collection = await Collection_1.Collection.create({
            title: data.title,
            slug: slug,
            description: data.description,
            type: data.type,
            filter: data.filter,
            featureImage: data.feature_image,
            deletable: data.deletable
        });
        if (collection.type === 'automatic' && collection.filter) {
            const posts = await this.postsRepository.getAll({
                filter: collection.filter
            });
            for (const post of posts) {
                collection.addPost(post);
            }
        }
        await this.collectionsRepository.save(collection);
        return this.toDTO(collection);
    }
    async addPostToCollection(collectionId, post) {
        const collection = await this.collectionsRepository.getById(collectionId);
        if (!collection) {
            return null;
        }
        collection.addPost(post);
        await this.collectionsRepository.save(collection);
        return this.toDTO(collection);
    }
    async updateAutomaticCollectionItems(collection, filter) {
        const collectionFilter = filter || collection.filter;
        if (collectionFilter) {
            const posts = await this.postsRepository.getAll({
                filter: collectionFilter
            });
            collection.removeAllPosts();
            for (const post of posts) {
                await collection.addPost(post);
            }
        }
    }
    async removePostFromAllCollections(postId) {
        // @NOTE: can be optimized by having a "getByPostId" method on the collections repository
        const collections = await this.collectionsRepository.getAll();
        for (const collection of collections) {
            if (collection.includesPost(postId)) {
                await collection.removePost(postId);
            }
        }
    }
    async addPostToMatchingCollections(post) {
        const collections = await this.collectionsRepository.getAll({
            filter: 'type:automatic'
        });
        for (const collection of collections) {
            const added = await collection.addPost(post);
            if (added) {
                await this.collectionsRepository.save(collection);
            }
        }
    }
    /**
     * @description Updates all automatic collections. Can be time intensive and is a temporary solution
     * while all of the events are mapped out and handled optimally
     */
    async updateCollections() {
        const collections = await this.collectionsRepository.getAll({
            filter: 'type:automatic'
        });
        for (const collection of collections) {
            await this.updateAutomaticCollectionItems(collection);
            await this.collectionsRepository.save(collection);
        }
    }
    async updatePostInMatchingCollections(postEdit) {
        const collections = await this.collectionsRepository.getAll({
            filter: 'type:automatic'
        });
        for (const collection of collections) {
            if (collection.includesPost(postEdit.id) && !collection.postMatchesFilter(postEdit.current)) {
                await collection.removePost(postEdit.id);
                await this.collectionsRepository.save(collection);
                logging_1.default.info(`[Collections] Post ${postEdit.id} was updated and removed from collection ${collection.id} with filter ${collection.filter}`);
            }
            else if (!collection.includesPost(postEdit.id) && collection.postMatchesFilter(postEdit.current)) {
                const added = await collection.addPost(postEdit.current);
                if (added) {
                    await this.collectionsRepository.save(collection);
                }
                logging_1.default.info(`[Collections] Post ${postEdit.id} was updated and added to collection ${collection.id} with filter ${collection.filter}`);
            }
            else {
                logging_1.default.info(`[Collections] Post ${postEdit.id} was updated but did not update any collections`);
            }
        }
    }
    async edit(data) {
        const collection = await this.collectionsRepository.getById(data.id);
        if (!collection) {
            return null;
        }
        const collectionData = this.fromDTO(data);
        await collection.edit(collectionData, this.uniqueChecker);
        if (collection.type === 'manual' && data.posts) {
            for (const post of data.posts) {
                collection.addPost(post);
            }
        }
        if (collection.type === 'automatic' && data.filter) {
            await this.updateAutomaticCollectionItems(collection, data.filter);
        }
        await this.collectionsRepository.save(collection);
        return this.toDTO(collection);
    }
    async getById(id) {
        return await this.collectionsRepository.getById(id);
    }
    async getBySlug(slug) {
        return await this.collectionsRepository.getBySlug(slug);
    }
    async getAll(options) {
        const collections = await this.collectionsRepository.getAll(options);
        const collectionsDTOs = [];
        for (const collection of collections) {
            collectionsDTOs.push(this.toDTO(collection));
        }
        return {
            data: collectionsDTOs,
            meta: {
                pagination: {
                    page: 1,
                    pages: 1,
                    limit: collections.length,
                    total: collections.length,
                    prev: null,
                    next: null
                }
            }
        };
    }
    async getAllPosts(id, { limit = 15, page = 1 }) {
        const collection = await this.getById(id);
        if (!collection) {
            throw new errors_1.NotFoundError({
                message: (0, tpl_1.default)(messages.collectionNotFound.message),
                context: (0, tpl_1.default)(messages.collectionNotFound.context, { id })
            });
        }
        const startIdx = limit * (page - 1);
        const endIdx = limit * page;
        const postIds = collection.posts.slice(startIdx, endIdx);
        const posts = await this.postsRepository.getBulk(postIds);
        return {
            data: posts,
            meta: {
                pagination: {
                    page: page,
                    pages: Math.ceil(collection.posts.length / limit),
                    limit: limit,
                    total: posts.length,
                    prev: null,
                    next: null
                }
            }
        };
    }
    async getCollectionsForPost(postId) {
        const collections = await this.collectionsRepository.getAll({
            filter: `posts:${postId}`
        });
        return collections.map(collection => this.toDTO(collection));
    }
    async destroy(id) {
        const collection = await this.getById(id);
        if (collection) {
            if (collection.deletable === false) {
                throw new errors_1.MethodNotAllowedError({
                    message: (0, tpl_1.default)(messages.cannotDeleteBuiltInCollectionError.message),
                    context: (0, tpl_1.default)(messages.cannotDeleteBuiltInCollectionError.context, {
                        id: collection.id
                    })
                });
            }
            collection.deleted = true;
            await this.collectionsRepository.save(collection);
        }
        return collection;
    }
    async removePostFromCollection(id, postId) {
        const collection = await this.getById(id);
        if (!collection) {
            return null;
        }
        if (collection) {
            collection.removePost(postId);
            await this.collectionsRepository.save(collection);
        }
        return this.toDTO(collection);
    }
}
exports.CollectionsService = CollectionsService;
